#toString

**Analisis de complejidad temporal**

Como el algoritmo recorre para sacar los valores de cada objeto depende de la longitud de la lista y por ende es de complejidad O(n)

#insertion

**Analisis de complejidad temporal**

El algoritmo lo que hace es recorrer la lista ligada con el fin de agregar el nuevo objeto, cosa, valor, etc hasta el final de la lista, por ende depende del tamanio de la lista y gracias a eso es de complejidad O(n)

#search

**Analisis de complejidad temporal**

Como recorremos la lista solo una vez hasta llegar al valor deseado dependemos de el valor ingresado, y en caso de que no este dependemos del tamanio de la lista y por eso la complejidad es de O(n)

#update

**Analisis de complejidad temporal**

Dependemos de la posicion que nos den ya que recorreremos la lista hasta llegar ahi, por ende la complejidad es de O(n)

#deleteAt

**Analisis de complejidad temporal**

Como en los otros algoritmos, recorremos la lista hasta llegar a la posicion deseada y ya ahi borramos el objeto deseado, gracias a que dependemos de eso la complejidad es de O(n)

